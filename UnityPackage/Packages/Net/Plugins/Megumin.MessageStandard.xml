<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Megumin.MessageStandard</name>
    </assembly>
    <members>
        <member name="T:Megumin.Remote.KeyAlreadyHave">
            <summary>
            Key冲突改怎么做
            </summary>
        </member>
        <member name="F:Megumin.Remote.KeyAlreadyHave.Replace">
            <summary>
            替换
            </summary>
        </member>
        <member name="F:Megumin.Remote.KeyAlreadyHave.Skip">
            <summary>
            跳过
            </summary>
        </member>
        <member name="F:Megumin.Remote.KeyAlreadyHave.ThrowException">
            <summary>
            抛出异常
            </summary>
        </member>
        <member name="T:Megumin.Remote.IMeguminFormater">
            <summary>
            通用序列化库接口
            </summary>
        </member>
        <member name="P:Megumin.Remote.IMeguminFormater.MessageID">
            <summary>
            消息识别ID
            </summary>
        </member>
        <member name="P:Megumin.Remote.IMeguminFormater.BindType">
            <summary>
            消息类型
            </summary>
        </member>
        <member name="M:Megumin.Remote.IMeguminFormater.Serialize(System.Buffers.IBufferWriter{System.Byte},System.Object,System.Object)">
            <summary>
            序列化函数
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="options"></param>
            <remarks>序列化函数不在提供序列化多少字节，需要在writer中自己统计</remarks>
        </member>
        <member name="M:Megumin.Remote.IMeguminFormater.Deserialize(System.Buffers.ReadOnlySequence{System.Byte}@,System.Object)">
            <summary>
            反序列化函数
            </summary>
            <param name="byteSequence"></param>
            <param name="options"></param>
            <returns></returns>
            <remarks>返回值不考虑泛型，泛型虽然能避免值类型消息装箱，但是调用时要使用反射去转化为
            对应类型接口，在rpc回调转型处仍然会有类型匹配失败问题，得不偿失。</remarks>
        </member>
        <member name="T:Megumin.Remote.IMeguminSelfFormater">
            <summary>
            对象自身就是序列化器，是MessageLut没注册时的fallback。
            </summary>
        </member>
        <member name="M:Megumin.Remote.IMeguminSelfFormater.SelfDeserialize(System.Buffers.ReadOnlySequence{System.Byte}@,System.Object)">
            <summary>
            先构造对象，然后自己解析。
            </summary>
            <param name="byteSequence"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="T:Megumin.Remote.MessageLUT">
            <summary>
            消息查找表
            </summary>
        </member>
        <member name="M:Megumin.Remote.MessageLUT.Regist(Megumin.Remote.IMeguminFormater,Megumin.Remote.KeyAlreadyHave)">
            <summary>
            注册序列化器
            </summary>
            <param name="meguminFormater"></param>
            <param name="key"></param>
        </member>
        <member name="M:Megumin.Remote.MessageLUT.RegistIMeguminFormater``1(Megumin.Remote.KeyAlreadyHave)">
            <summary>
            注册序列化器
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
        </member>
        <member name="M:Megumin.Remote.MessageLUT.Serialize(System.Buffers.IBufferWriter{System.Byte},System.Object,System.Object)">
            <summary>
            序列化一个对象到指定writer
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="options"></param>
            <returns>消息ID</returns>
            <remarks>序列化函数不在提供序列化多少字节，需要在writer中自己统计</remarks>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Megumin.Remote.MessageLUT.Deserialize(System.Int32,System.Buffers.ReadOnlySequence{System.Byte}@,System.Object)">
            <summary>
            反序列化
            </summary>
            <param name="messageID"></param>
            <param name="byteSequence"></param>
            <param name="options"></param>
            <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Megumin.Remote.MessageLUT.Deserialize``1(System.Buffers.ReadOnlySequence{System.Byte}@,System.Object)">
            <summary>
            反序列化
            </summary>
            <param name="byteSequence"></param>
            <param name="options"></param>
            <returns></returns>
            <remarks>有时即使类型不匹配也能反序列化成功，但得到的值时错误的</remarks>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
        </member>
        <member name="M:Megumin.Remote.MessageLUT.GetType(System.Int32)">
            <summary>
            查找消息类型
            </summary>
            <param name="messageID"></param>
            <returns></returns>
        </member>
        <member name="M:Megumin.Remote.MessageLUT.TryGetType(System.Int32,System.Type@)">
            <summary>
            查找消息类型
            </summary>
            <param name="messageID"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Megumin.Remote.MessageLUT.GetID``1">
            <summary>
            查找消息ID
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Megumin.Remote.MessageLUT.GetID(System.Type)">
            <summary>
            查找消息ID
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Megumin.Remote.MessageLUT.TryGetID``1(System.Int32@)">
            <summary>
            查找消息ID
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ID"></param>
            <returns></returns>
        </member>
        <member name="M:Megumin.Remote.MessageLUT.TryGetID(System.Type,System.Int32@)">
            <summary>
            查找消息ID
            </summary>
            <param name="type"></param>
            <param name="ID"></param>
            <returns></returns>
        </member>
        <member name="T:Megumin.Remote.BufferWriterBytesSteam">
            <summary>
            包装<see cref="T:System.Buffers.IBufferWriter`1"/><see cref="T:System.Byte"/>成一个长度无限的只写流，
            只有<see cref="M:Megumin.Remote.BufferWriterBytesSteam.Write(System.Byte[],System.Int32,System.Int32)"/>函数起作用。
            </summary>
        </member>
        <member name="T:Megumin.Remote.DebugLogger">
            <summary>
            
            </summary>
        </member>
        <member name="T:Megumin.Remote.MSGID">
            <summary>
            使用MessageID来为每一个消息指定一个唯一ID(-999~999 被框架占用)。
            请查看常量。
            </summary>
        </member>
        <member name="M:Megumin.Remote.MSGID.op_Implicit(Megumin.Remote.MSGID)~System.Int32">
            <summary>
            
            </summary>
            <param name="attribute"></param>
        </member>
        <member name="M:Megumin.Remote.MSGID.#ctor(System.Int32)">
            <summary>
            消息ID
            </summary>
            <param name="id"></param>
        </member>
        <member name="P:Megumin.Remote.MSGID.ID">
            <summary>
            消息类唯一编号
            </summary>
        </member>
        <member name="F:Megumin.Remote.MSGID.ErrorType">
            <summary>
            错误的类型，表示框架未记录的类型。不是void，也不是任何异常ErrorType。
            </summary>
        </member>
        <member name="F:Megumin.Remote.MSGID.UdpConnectMessageID">
            <summary>
            Udp握手连接使用的消息ID编号
            </summary>
        </member>
        <member name="F:Megumin.Remote.MSGID.HeartbeatsMessageID">
            <summary>
            心跳包ID，255好识别，buffer[10-13]=[255,0,0,0]
            </summary>
        </member>
    </members>
</doc>
